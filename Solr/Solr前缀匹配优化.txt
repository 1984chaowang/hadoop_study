环境:Solr 6.2.0集群 
数据量:公司16亿,南充1.5亿

由问题引入:
开发中在遇到模糊匹配时发现: 加入后模糊匹配 性能还可以接受,但是加入前模糊匹配,查询速度质的下降
定位问题,发现瓶颈主要是在solr上,需要在底层优化或者根据业务在代码层优化 

现在的实现:
通配符+查询域+通配符  --> *A123* 
	功能可以实现,但开销很大    所以ES:直接不支持前缀匹配 

Solr模糊匹配的原理:
一旦使用通配符的查询,那么在关键字中第一个通配符之前的部分需要在倒排索引中全部查询出来
每个查询出来的结果在逐一进行检查，看是否符合查询条件
所以观察到的现象就是: 在通配符之前的字符越多，那么查询将会越快

比如:浙A7777* 进行查询效率就会很高 ,因为浙A7777在反向索引中匹配不会有太多的匹配
	 但是浙A* 查询开销就会很大,因为它将匹配所有浙A开头的数据 然后在进行比较 
	 如果是*A* 则会取出所有的数据,进行比较,项目中已经有后缀匹配,所以效率现在是5-6s



==========先考虑下用户是怎么操作的?==========
用户可能是随便输123,可能包含地区的缩写,也可能不包含 但是肯定不会输入汉字,比如赣 
可能查全天
可能查某辆车



 
第一种解决方案是:在代码中实现当用户手动输入 先从配置文件中获取当前地方的号牌前缀  
赣A:直接作为前缀拼接上去   在代码中做判断: 如果输入的查询条件不包含"赣A" ,就拼接上赣A

伪代码:
通过判断输入的长度 ?  7位 执行精确查询

else if 输入的第一位是否包含本地号牌 :比如"赣"  或者 直接判断是否包含汉字(如果是乱输,不能查出来)  
		改掉了,现在使用solr中查的 对比   直接判断首字母是否包含汉字
	 是:就不需要前缀匹配,直接拼接后缀模糊匹配    (乱输:你好   进行拼接在solr中搜索,查不到,满足判断)
	 
	 else(不包含汉字)
		(是否可以在前面直接拼接 配置表的程序部署地的号牌开头:  赣A  +输入 +后缀通配符?)
		if首字母是否为26英文字母 否  直接拼接本省+本市号牌标识  比如 赣A + 输入+后缀通配符 
		else 拼接 本省号牌缩写    赣+A123+后缀通配符
拼接后的查询字段 作为fq的参数进行搜索
		
测试:用户胡乱输入
	 输入123        默认用户测着完补上 赣A -->赣A123*
	 输入A123       
	 输入警123      满足:警123*,索引中可以查到

实现:在solr查询接口加上面伪代码测试  
	 加properties文件-->本省号牌缩写赣 ,本地号牌缩写赣A ? 
		缺点:卓佳成那边要维护两份properties
	 从数据库查? 会更慢
	 荣哥那边为了保持唯一性,会先查一次solr,取出十条数据的字段类型 放到map中
	 可以利用这一段: 获取十条solr的查询,在jvm中做处理.取出10条号牌的值截取的前两位进行降序排序,
	 所在地的号牌前缀就有了,几十毫秒 
	 
怀疑:10条能不能准确的定位到solr部署的所在地,需要测试jvm运算 跟solr查询的关系  
	 
16亿  一天
测试*123*-->9s  服务器3s
	赣A123 -->2.5s 服务器  0.8s 
1.5亿

南充的服务器配置更差一点,但数据量更少
测试	
测试*123*-->13s   服务器4s
	川R123*-->0.78s 服务器 200毫秒  页面整体响应2s   
预估:修改后应该能保证原有的查询效率2s-2.5s

测试:需要先记录南充和公司现在的速度,拿1/3对服务器做对比


==============================================
第一种方法见效更快,对其他代码影响小,性能可以达到
第二种方式对solr深入应用更有帮助,但设计的程序改动太多,索引也需要重新创建 
	性能提升小 
==============================================

第二种:
解决方案:调用 通配符反转过滤器,专门用来解决前缀匹配的 (将字段保存两份,其中一份倒序列排列来加速左通配)
引入:ReversedWildcardFilterFactory  
会插入两条记录到Solr的索引中(一条是域值的正向文本内容,一条是域值的反向文本内容)
eg:licenseNumber:赣A6X518 底层会多保存一份为 815X6A赣,当solr/select检测到左统配 会用反向存储的域值进行匹配

使用条件 && 优缺点:
ReversedWildcardFilterFactory只能使用在Text类型下的 <Analysis>
<Analysis>中可以进行Solr中对文本进行分析的高级应用,比如分词,反向索引 
现阶段所有的域值都是用的是string 所以下一步建议是将性能差的域类型 由string-->text 
licenseNumber 号牌这个作为搜索 ,通过通配符反转过滤器提高检索性能,
			  缺点是 对应的域值需要存两份,增加索引,占用一倍内存   
影响程序:
	创建索引
	查询接口

步骤:新增加一个text的域类型   
	 切换域licenseNumber的type   
	 创建索引测试 
测试:
切换后新创建的索引的字段会变成text ? 会不会影响查询 

测试使用 现在正在更新的

历史数据已经不能改变了,16亿条  


========================================================================
<fieldType name="text_rvswc" class="solr.TextField" positionIncrementGap="100">  
   <analyzer type="index">  
     <tokenizer class="solr.WhitespaceTokenizerFactory"/>  
     <filter class="solr.ReversedWildcardFilterFactory" withOriginal="true"  
             maxPosAsterisk="2" maxPosQuestion="1" minTrailing="2" maxFractionAsterisk="0"/>  
   </analyzer>  
   <analyzer type="query">  
     <tokenizer class="solr.WhitespaceTokenizerFactory"/>  
   </analyzer>  
 </fieldType> 
=========================================================================
提高性能的域 :
<field name="licenseNumber" type="string" indexed="true" stored="true"/>  
 
=========================================================================
现在域所引用的域值 :
<fieldType name="string" class="solr.StrField" sortMissingLast="true"/>

=========================================================================
注:如果想使用左模糊匹配优化的ReversedWildcardFilterFactory
   必须该字段类型是TextField文本字段 
   因为文本字段才可以指定文本解析器 ,即域值引用的类型的class必须是solr.TextField文本字段


1:需要修改的字段类型:
2:需要左模糊查询的指向这个字段类型  
不能修改原有的  新加一个字段fieldType name="string_reverse",
				字段class="solr.StrField" 字符串类型
				positionIncrementGap="100"
废弃:不能使用非文本类型的字段指定文本解析器 

	


=======第二种方式测试========
实验:在新增的配置集上修改 VioLicenseConf  使用 测试的collection使用   数据量太小
还是在kkrecords上做吧  大不了再改回来  测试环境  
修改前:16亿数据 
licenseNumber:*11* 23s    licenseNumber:*22*  22.6s
加上时间 passingTime:[2016-03-01T00:00:00Z TO 2016-03-01T23:59:59Z]   24s
====================================







